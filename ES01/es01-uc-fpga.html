<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=1024" />
    <title>ENGN8537 Lecture 1: Microcontrollers and FPGAs</title>

    <link href="fonts/roboto/stylesheet.css" rel="stylesheet" />
    <link href="fonts/droidsans-mono/stylesheet.css" rel="stylesheet" />
    <link href="fonts/fontello/css/fontello.css" rel="stylesheet" />
    <link href="js/google-code-prettify/prettify.css" rel="stylesheet" />
    <link href="css/es01.css" rel="stylesheet" />
</head>

<body class="impress-not-supported">
<div class="fallback-message">
    <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
    <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
</div>

<a class="ov-link" href="#overview">Overview</a>

<div id="impress">
    <!-- Title slide -->
    <div id="title" class="step slide" data-x="0" data-y="0">
        <div class="logo">
            <img src='images/ANU_LOGO_cmyk_56mm-large.png' width='200' />
        </div>

        <div class="headbox">
            <p>Research School of Engineering</p>
            <p class="course">ENGN8537: Embedded Systems and Real Time Digital Signal Processing</p>
        </div>
        <div class="titlebox">
            <h1>Microcontrollers and FPGAs</h1>
            <h2>Review</h2>
        </div>
        <div class="linkbox">
            <a href="?print">print view</a>
        </div>
    </div>

    <div class="step" id="deftitle" data-x="1200" data-y="0">
        <h1>Definitions</h1>
    </div>

    <div class="step" id="definitions" data-x="1200" data-y="600">
        <div class="card" id="mp">Microprocessor</div>
        <div class="darrow-m-h" id="d1"></div>
        <div id="asic">ASIC/ASSP</div>
        <div class="larrow-m-h" id="l1"></div>
        <div class="listcard" id="ex"><ul>
            <li>Memory</li>
            <li>Interfaces</li>
            <li>Sensors</li>
            <li>Controllers</li>
        </ul></div>
        <div class="rarrow-m-h" id="r1"></div>
        <div id="p1">&#59416;</div>
        <div class="rarrow-m-h" id="r2"></div>
        <div id="uc">Microcontroller</div>
        <div class="darrow-m-h" id="d2"></div>
        <div id="soc">SoC</div>
        <div class="darrow-m-h" id="d3"></div>
        <div id="fpga">FPGA</div>
        <div class="rarrow-m-h" id="r3"></div>
        <div id="p2">&#59416;</div>
        <div class="rarrow-m-h" id="r4"></div>
        <div id="psoc">PSoC<br/>FPGA-SoC<br/>FPSLIC<br/>&hellip;</div>
    </div>

    <div class="step" id="def-asic" data-x-rel="-450" data-y-rel="50" data-scale="0.5">
        <div style="float:left;font-size:36px;padding-right:30px">Application Specific</div>
        <div style="float:left;position:relative;top:-24px;font-size:32px"><b>Integrated Circuit<br/>Standard Product</b></div>

        <div style="clear:both;padding-top:20px"><ul>
            <li><b>ASIC:</b> Single-customer integrated circuit</li>
            <li><b>ASSP:</b> General-sale integrated circuit</li>
            <li>Non-programmable</li>
            <li>Specific purpose</li>
        </ul></div>
    </div>

    <div class="step" id="def-up" data-x-rel="750" data-y-rel="-350" data-scale="0.5">
        <div style="float:right"><ul>
            <li>Processor <b>only</b> (ALU, Registers, &hellip;)</li>
            <li>Traditionally doesn't even include Cache</li>
            <li>Requires support components</li>
        </ul></div>
    </div>

    <div class="step" id="def-uc" data-x-rel="50" data-y-rel="325" data-scale="0.5">
        <div style="float:right"><ul>
            <li><b>SoC:</b> System on Chip</li>
            <li><b>Microcontroller</b> / <b>SoC</b> often used interchangeably</li>
            <li>Processor plus integrated support components</li>
            <li>Microcontroller generally smaller, less capable</li>
        </ul></div>
    </div>

    <div class="step" id="def-fpga" data-x-rel="-450" data-y-rel="375" data-scale="0.5">
        <ul>
            <li><b>FPGA:</b> Field-programmable Gate Array</li>
            <li>Programmable logic cells and interconnects</li>
            <li>May be programmed to protoype, replicate <b>digital</b> ASIC/ASSP logic</li>
            <li>May be programmed to include <b>&ldquo;soft-core&rdquo;</b> processors, SoCs</li>
            <li>Slower, more expensive than dedicated chips with the same purpose</li>
        </ul><br/>
        See also: CPLD, GAL, PAL, &hellip;
    </div>

    <div class="step" id="def-psoc" data-x-rel="700" data-y-rel="-130" data-scale="0.5">
        <div style="float:right"><ul>
            <li><b>PSoC:</b>Programmable System on Chip</li>
            <li><b>FPSLIC:</b> Field-Programmable System-level Integrated Circuit</li>
            <li><b>Hybrids</b> combine strengths of SoC and FPGA</li>
            <li>&ldquo;Burned-in&rdquo; SoC parts alongside programmable logic</li>
            <li>Becoming more popular</li>
            <li>May also include programmable <b>analogue</b> fabric (esp. PSoC)</li>
        </ul></div>
    </div>

    <div class="step" id="def-ov" data-x="1200" data-y="650" data-scale=1.1></div>

    <div class="step" id="verilog1" data-x="0" data-y="800" data-scale=1.0>
        <h1>Verilog</h1>
        <ul>
            <li>Hardware Description Language <b>HDL</b></li>
            <li>Big, but most constructs only used in simulation</li>
            <li>Not a programming language! Rather a formalism for describing digital logic</li>
            <li>You must understand what hardware elements are described by your Verilog</li>
        </ul>
    </div>

    <div class="step point" data-x-rel="0" data-y-rel="400">
        If your Verilog isn’t working, try <b>sketching</b> the logic gates and registers yourself.  If you can’t make your Verilog look like good hardware, the synthesizer probably can’t either!
    </div>

    <div class="step" id="logic-classes" data-x="0" data-y="1500">
        <h1>Classes of Logic</h1>
        <div style="float:left"><h1 class="small">Combinatorial</h1></div>
        <div style="float:right"><h1 class="small">Sequential</h1></div>
    </div>

    <div class="step" id="class-comb" data-x="-365" data-y="1740" data-scale="0.6">
        <div style="margin-top:80px;text-align:center"><img src="images/verilog/combinatorial.png" width="600px"/></div>
        <div style="float:left;"><b class="code">assign</b> Style<br/><pre class="card prettyprint lang-verilog">
module Module_Name (input wire [3:0] InVar1,
                    input wire [3:0] InVar2,
                    output wire [3:0] OutVar1,
                    output wire OutVar2);
    assign OutVar1 = InVar1^InVar2;
    assign OutVar2 = &InVar2;
endmodule
</pre></div>
        <div style="float:right"><b class="code">always</b> Style<br/><pre class="card prettyprint lang-verilog">
module Module_Name (input wire [3:0] InVar1,
                    input wire [3:0] InVar2,
                    output wire [3:0] OutVar1,
                    output wire OutVar2);
    always &(*) begin
        OutVar1 = InVar1^InVar2;
        OutVar2 = &InVar2;
    end
endmodule
</pre></div>
    
    </div>

    <div class="step" data-x-rel="0" data-y-rel="500" data-scale="0.6">
        <h1>Rules for combinatorial circuits</h1>
        <ul><li>No feedback allowed</li>
        <li><code>assign</code> or <code>always@(*)</code> statements may be used</li>

        <h2 class="code">assign</h2><div style="float:left"><ul>
            <li>Compact</li>
            <li>Used for simple wiring tasks</li>
        </ul></div>
        <div class="card" style="float:right;width:45%"><code class="prettyprint lang-verilog">assign reset_n = key[0];</code></div>
        <div style="clear:both;"></div>
        <h2 class="code">always</h2>
        <div style="float:left">
        <ul><li>Flexible</li>
            <li>Leads in to Sequential Logic</li>
            <li>Contains <b>&ldquo;Sensitivity List&rdquo;</b></li>
        </ul></div>
        <div class="card" style="float:right;width:45%"><code class="prettyprint lang-verilog">always @(*) reset_n = key[0];</code></div>
    </div>

    <div class="step point" data-x-rel="0" data-y-rel="300" data-scale="0.6">
        A Combinatorial sensitivity list may be <b>individual wires</b> or <b>‘*’</b>.  If do not lost a signal that is used as an input to the block, then the logic is no longer strictly combinatorial and may not synthesize as you expect.
    </div>

    <div class="step point" data-x-rel="0" data-y-rel="250" data-scale="0.6">
        Loops are <b>not</b> allowed <br/><br/><pre class="prettyprint lang-verilog bad">
assign X = Y | Z;
assign Y = X ^ W;</pre>
        <div class="notes">WRONG! Such structures must be implemented in sequential form (if they're really what you want)</div>
    </div>

    <div class="step" id="if" data-x-rel="0" data-y-rel="300" data-scale="0.6">
        <h1><code>if</code> Statements</h1>
        <div class="card" style="float:left;height:370px;margin-right:30px"><pre class="prettyprint lang-verilog">
module Module_Name (input wire [3:0] InVar1,
                    input wire [3:0] InVar2,
                    output wire [3:0] OutVar1,
                    output wire OutVar2);
    always &(*) begin
        OutVar2 = &InVar2;
        if (&InVar2) begin
            OutVar1 = InVar1;
        end else begin
            OutVar1 = InVar2;
        end
    end
endmodule
</pre></div>
        <div style="float:left"><img style="height:400px" src="images/verilog/comb-if-schem.png"/></div>
    </div>

    <div class="step" id="if2" data-x-rel="350" data-y-rel="0" data-scale="0.6">
        <div style="float:right"><ul>
        <li>A wire representing the outcome of the test</li>
        <li>A multiplexor that selects the correct input signal</li></ul></div>
    </div>

    <div class="step point" data-x-rel="-350" data-y-rel="300" data-scale="0.6">
        <code>if</code> cases should be <b>Complete</b><br/><br/>
        <pre class="bad prettyprint lang-verilog">
always @(*) begin
    if (&InVar2) begin
        OutVar1 = InVar2;
        OutVar2 = &InVar2;
    end
end
</pre>
        <div class="notes">WRONG! You must include an 'else' statement here.</div>
    </div>

    <div class="step" data-x-rel="0" data-y-rel="250" data-scale="0.6">
        <h1><code>case</code> Statements</h1>
        <p>General case of <code>if</code> statements</p>
        <ul>
        <li>A <b>bus</b> representing the outcome of the test</li>
        <li>A multiplexor that selects the correct input signal</li></ul>
        <p>Like <code>if</code> statements, they should be <b>complete</b> to avoid the generation of latches</p>
    </div>

    <div class="step" id="class-seq" data-x="365" data-y="1740" data-scale="0.6">
    <div style="float:left;"><ul>
        <li>Has &ldquo;memory&rdquo; or &ldquo;state&rdquo;</li>
        <li><b>D-type</b> flip-flop is the basic unit</li>
    </ul></div>
    <div style="float:right;"><img src="images/verilog/seq-d.png" width="400px"/></div>
    </div>

    <div class="step point" data-x-rel="0" data-y-rel="300" data-scale="0.6">
        <b>Sequential</b> means &ldquo;has state&rdquo;. <b>Synchronous</b> means &ldquo;uses a clock signal&rdquo;.  Most sequential circuits and synchronous and most synchronous circuits are sequential, however this is not always the case.
    </div>

    <div class="step" data-x-rel="0" data-y-rel="300" data-scale="0.6">
        <h1>Rules for sequential circuits</h1>
        <div style="float:left">
        <ul><li>Feedback <b>is</b> allowed</li>
        <li>Non-blocking assignments used</li>
        <li><code>if</code>, <code>case</code> need not be complete</li>
        </div>

        <div style="float:right;margin-top:20px;">
        <div class="card"><pre class="prettyprint lang-verilog">
if (a)
    b <= c;</pre></div>
        </div>
    </div>

    <div class="step" data-x-rel="0" data-y-rel="300" data-scale="0.6">
        <h1>System Clock</h1>
        <div style="float:left;width:50%">Synchronous logic requires a clock signal. If the externally-supplied clock is too high, it can be divided. This should <b>not</b> be done using logic signals.</div>
        <div class="card bad" style="float:right"><pre class="prettyprint lang-verilog">
reg [1:0] my_clock;
always @(posedge clk) begin
    my_clock <= my_clock + 1;
end

always @(posedge my_clock[1]) begin
    …
end</pre></div>
        <div class="notes">Be careful with this type of divider, see later slides.</div>
    </div>

    <div class="step point" data-x-rel="600" data-y-rel="0" data-scale="0.6">
        <p>Logic signals (wires, regs) are slow. Clock signals must be routed using special <b>clock lines</b> internal to the FPGA to avoid timing problems.</p>

        <p>Clock division should be done using a state machine inside the always block, keeping only the main clock signal in the sensitivity list.</p>

        <div class="notes">
            In Altera devices, these are known as GCLKs. They are automatically used when using external clock pins. They <b>might</b> be automatically used if the synthesizer notices that you're using logic lines as clock signals. If the software does not notice, then you will have timing problems. This is investigated more in the labs.
        </div>
    </div>

    <div class="step" data-x-rel="0" data-y-rel="500" data-scale="0.6">
        <h1>Clock Infrastructure</h1>
        <div style="margin-top:40px;text-align:center"><img src="images/verilog/fpga-clocks.png" width="600px"/></div>

        <div class="notes">4 Phase Locked Loops (PLL), feeding the GCLKs in the FPGA. These should be used for all custom clock rate generation. They are capable of increasing the frequency of the clock, not just decreasing like a divider or state machine could.</div>
    </div>

    <div class="step" data-x="1700" data-y="1700" data-scale="1.0">
        <h1>State Machines</h1>
        <div style="float:left"><b>Mealy</b> Machine<br/><img src="images/state-machines/mealy-machine.png" style="width:450px"/></div>
        <div style="float:right"><b>Moore</b> Machine<br/><img src="images/state-machines/moore-machine.png" style="width:450px;padding-top:10px" /></div>

        <div style="clear:both">We only consider <b>synchronous</b> state machines.</div>

        <div class="notes">Asynchronous state machines are an interesting research topic but have not found widespread practical adoption due to issues with "races": Transitions through strange states due to issues of signal timing</div>
    </div>

    <div class="step" data-x-rel="0" data-y-rel="500" data-scale="0.6">
        <h1>Transition Diagrams</h1>
        <div style="text-align:center"><img src="images/state-machines/transitions.png" /></div>

        <div class="notes">A Moore machine has the input as a transition and output as part of the state. A Mealy machine has both the input and output drawn on a transition (though the input is the cause of the transition, the output is an effect).</div>
    </div>

    <div class="step" data-x-rel="0" data-y-rel="400" data-scale="0.6">
        <h1>FSM Design</h1>
        <ol>
        <li>Determine the inputs / outputs.</li>
        <li>Determine the states and give them mnemonic names</li>
        <li>Draw up a state diagram and a next state table</li>
        <li>Render the inputs, outputs and states in binary format</li>
        <li>Draw an excitation table</li>
        <li>Draw an Output table</li>
        <li>Implement transition and next-state logic.</li>
        <li>Simulate your design and check for correct operation.</li>
        <li>Check for potential practical problems (e.g. non-ideal effects).</li>
        </ol>

        <div class="notes">It is usually not important to manually minimise the implemented logic (e.g. Karnaugh maps), nor to worry about the exact form of the state representation (Gray code, one-hot, binary etc). The synthesizer will recognize your state machine logic and will implement the most efficient style of state machine it can.

A corrolorary of this is that your code should not <b>depend</b> on any particular state representation, as this will limit the optimizations that the synthesizer can make.
        </div>
    </div>

    <div class="step" id="def-up2" data-x="1500" data-y="300" data-scale="0.5">
    </div>

    <div class="step" id="up-arch" data-x-rel="1500" data-y-rel="0" data-scale="1.0">
        <h1>Microprocessor Architectures</h1>
        <div style="float:left;width:33%"><h1 class="small" style="text-align:left">MU0</h1></div>
        <div style="float:left;width:33%"><h1 class="small">AVR</h1></div>
        <div style="float:left;width:33%"><h1 class="small" style="text-align:right">Nios2</h1></div>
    </div>

    <div class="step" id="mu0" data-x-rel="-425" data-y-rel="200" data-scale="0.4">
        <div style="float:left">
        <ul>
        <li>Simple, Realistic</li>
        <li>Two-cycle execution</li>
        <li>Key components:<ul>
            <li>ALU</li>
            <li>Memory</li>
            <li>Register (ACC)</li>
            </ul></li>
        </ul>
        </div>
        <div style="float:right">
        <img src="images/micros/mu0.png" /><p>
        <b>MU0</b> data path</p>
        </div>

        <div class="notes">
            A realistic but simple processor which is capable of executing one instruction every two clock cycles.

    We won’t be looking at this in labs, but the data path and control flows will be used in illustrating many of the more advanced topics in microprocessors over the coming lectures
        </div>
    </div>

    <div class="step" data-x-rel="0" data-y-rel="250" data-scale="0.4">
        <h1>Instruction Timing</h1>
        <div style="text-align:center">
        <img src="images/micros/mu0-logic.png" /><p>
        </div>

        <div class="notes">
        Timing is important to understand.  The processing of a single instruction is split in to two parts, one per clock cycle:  Fetch and Execute.

Thus each instruction takes two clock cycles to complete.

Actually there are four states with the two corresponding to memory accesses occurring on the falling edges, between the explicit states.  This is valid as MU0 is simple and runs slowly.  When we get to more complex systems, we’ll note that these extra states are made explicit themselves.
        </div>
    </div>


    <div class="step" data-x-rel="0" data-y-rel="250" data-scale="0.4">
        <h1>Fetch</h1>
        <div style="float:left;width:60%">
        <ul>
            <li>Read Program Counter</li>
            <li>Set up MEM for instruction access</li>
            <li>Access happens on next falling edge</li>
            <li>Postcondition: IR is loaded</li>
        </ul>
        </div>
        <div style="float:right">
        <img src="images/micros/mu0-fetch.png" /><p>
        </div>

        <div class="notes">
            During the Fetch cycle, the Program Counter is wired in to the memory address, and the instruction at that location is loaded in to the Instruction Register.
        </div>
    </div>

    <div class="step" data-x-rel="0" data-y-rel="300" data-scale="0.4">
        <h1>Execute</h1>
        <div style="float:left;width:60%">
        <ul>
            <li>Read IR</li>
            <li>Set up ALU inputs</li>
            <li>Computation happens combinatorially</li>
            <li>Set up MEM for result write</li>
            <li>Access happens on next falling edge</li>
            <li>Postcondition: Instruction is Executed</li>
        </ul>
        </div>
        <div style="float:right">
        <img src="images/micros/mu0-execute.png" /><p>
        </div>

        <div class="notes">
            The Execute phase is centred around the Arithmetic Logic Unit (ALU).  It takes two operands, one of which is always a register (either the Accumulator or the Program Counter depending on the operation).  The other is either a memory location whose address is coded in to the instruction, or some portion of the instruction itself.
        </div>
    </div>

    <div class="step" id="avr" data-x="3000" data-y="475" data-scale="0.4">
        <div style="float:left">
        <ul>
            <li>PC, MEM, IR, ALU like MU0</li>
            <li>More registers</li>
            <li>Split memory for data and program</li>
        </ul>
        </div>
        <div style="float:right">
        <img src="images/micros/mega8.png" style="width:300px" /><p>
        </div>

        <div class="notes">
            This basic structure is very similar across all CPUs.  Here we see the CPU portion of the Atmel ATMega8 microcontroller.

Program Counter, Instruction Register, ALU, Memory busses all pretty much the same.

Differences: MU0 has one working register, ACC, Mega8 has 32 (6 of which can be paired in to 3 special registers, XYZ, of twice the size).  Different memory architecture, MU0 has a single memory to hold instructions and data, the AVR has two blocks labeled Program Flash and SRAM respectively.
        </div>
    </div>

    <div class="step" id="nios" data-x="3400" data-y="475" data-scale="0.4">
        <div style="float:left">
        Used as <b>soft core</b> in Altera FPGAs
        <ul>
            <li>PC, MEM, IR, ALU like MU0</li>
            <li>More registers</li>
            <li>Complex interrupt handling</li>
            <li>Even more memory types</li>
        </ul>
        </div>
        <div style="float:right">
        <img src="images/micros/nios.png" style="width:500px" /><p>
        </div>

        <div class="notes">
            The Nios2 core we will be using in labs is more complex again, but uses the same concepts still.

Note the register sets, the ALU and the Program Controller (that includes the Program Counter, Instruction Register etc.).

Most of the extra complexity here is to do with interrupts (not yet covered) or simply accessing many more types of memories.
        </div>
    </div>


<!-- Overview pseudo-slide, the data-* elements are filled in by the positioner script -->
<div id="overview" class="step"/>



</div>


<script src="js/impress.js"></script>
<script src="js/impressConsole.js"></script>
<script src="js/google-code-prettify/prettify.js"></script>
<script src="js/google-code-prettify/lang-verilog.js"></script>
<script>
// Call Impress even if it won't be initialized so we at least
// get .impress-disabled set up and testable from CSS
impress()
prettyPrint()
if ( !window.location.search.match(/print/) ) {
    impress().init();
    impressConsole().init();
}</script>

</body>
</html>

